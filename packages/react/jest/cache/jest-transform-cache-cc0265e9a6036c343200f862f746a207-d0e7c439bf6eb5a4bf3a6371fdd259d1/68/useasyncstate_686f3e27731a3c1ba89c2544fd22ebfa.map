{"file":"/Users/jiangwei/projects/lotips/packages/react/src/use-async-state.ts","mappings":";AAAA;;;;;;;;;;;;;;;GAeG;;AAEH,+BAAgD;AAMnC,QAAA,aAAa,GAAG,UAC3B,KAAS,EACT,EAAwE;QAAtE,8DAAqB,EAArB,0CAAqB;IAEjB,IAAA,gCAAqC,EAApC,aAAK,EAAE,WAA6B,CAAA;IAC3C,IAAM,GAAG,GAAG,eAAO,CAAC;QAClB,OAAO,KAAK,KAAK,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAA;IAC5C,CAAC,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,SAAS,CAAC,CAAC,CAAA;IAC7B,OAAO,CAAC,GAAG,EAAE,GAAG,CAAiD,CAAA;AACnE,CAAC,CAAA","names":[],"sources":["/Users/jiangwei/projects/lotips/packages/react/src/use-async-state.ts"],"sourcesContent":["/**\n * WHY:\n * ```tsx\n * const [state, setState] = useState()\n * useEffect(() => {\n *  const fetch = async () => {\n *     const data = await api()\n *     setState(data)\n *  }\n * }, [])\n * NOTE:\n * - 但有时数据是来自redux的异步获取，在以下假设下该hook比较实用。没有相应的state action，或者不需要相应的state action\n * WARNING:\n * - 适合对同一个ID的对象进行修改。在`Form`中的涉及到重复的初始化的情况，不太合适`useAsyncState`\n * ```\n */\n\nimport React, { useState, useMemo } from 'react'\n\nexport type UseAsyncStateProps = {\n  nullstate?: any\n}\n\nexport const useAsyncState = <T>(\n  value?: T,\n  { nullstate = undefined }: UseAsyncStateProps = { nullstate: undefined },\n) => {\n  const [state, set] = useState<T>(nullstate)\n  const get = useMemo(() => {\n    return state === nullstate ? value : state\n  }, [value, state, nullstate])\n  return [get, set] as [T, React.Dispatch<React.SetStateAction<T>>]\n}\n"],"version":3}